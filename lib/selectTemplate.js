const { prompt } = require("enquirer");
const path = require("path");
const fs = require("fs");
const { validateTemplate } = require("./util");

const loadHookTemplates = () => {
    const filePath = path.resolve(__dirname, "hookTemplateCompatibility.json");
    const rawData = fs.readFileSync(filePath);
    return JSON.parse(rawData);
};

const hookTemplates = loadHookTemplates();

const selectTemplate = async (hookType) => {
    try {
        const choices = hookTemplates[hookType];

        if (!choices) {
            console.error(`❌ No templates available for the ${hookType} hook.`);
            return;
        }

        const choicesWithCustom = [
            ...choices,
            { name: "Custom (create your own)", value: "custom" },
        ];

        if (!choices) {
            console.error(`❌ No templates available for the ${selectedHook} hook.`);
            return;
        }

        const { templates } = await prompt([
            {
                type: "multiselect",
                name: "templates",
                message: `Select templates for ${hookType} (Space: select, A: all, I: invert, Enter: confirm):`,
                choices: choicesWithCustom.map((choice) => ({
                    name: choice?.requiresConfig
                        ? `${choice.name}: requires configuration`
                        : choice.name,
                    value: choice.value,
                })),
                validate: (value) =>
                    value.length > 0 ? true : "❌ You must select at least one template.",
            },
        ]);

        if (
            templates.includes("Custom (create your own)") &&
            templates.length > 1
        ) {
            console.warn(
                `⚠️ You selected both 'Custom' and predefined templates. 'Custom' will be applied, and others will be ignored.`,
            );
            return ["custom"];
        }

        const selectedTemplates = templates.map((templateValue) => {
            return choicesWithCustom.find(
                (choice) => choice.name === templateValue.split(":")[0],
            );
        });

        const templatesNeedingConfig = selectedTemplates.filter(
            (t) => t.requiresConfig,
        );

        if (templatesNeedingConfig.length > 0) {
            console.warn(
                `⚙️ The following templates require additional configuration:`,
            );
            templatesNeedingConfig.forEach((template) => {
                console.warn(`- ${template.name}: ${template.requiresConfig}`);
            });
        }

        return selectedTemplates.map((t) => t.value);
    } catch (err) {
        console.error(`❌ Template selection failed: ${err.message}`);
        throw err;
    }
};

const generateTemplateContent = async (templates, hook) => {
    let mergedContent = `#!/bin/sh\n\n# Generated by GitPodify\n\n`;
    for (const template of templates) {
        let templateContent = "";
        if (template === "custom") {
            const { customTemplatePath } = await prompt({
                type: "input",
                name: "customTemplatePath",
                message: "Enter the absolute path to your custom template file:",
                validate: (value) =>
                    validateTemplate(value) ? true : "Invalid path or file format.",
            });
            templateContent = fs.readFileSync(customTemplatePath, "utf8");
        } else {
            const templatesDir = path.join(process.cwd(), "lib", "templates", hook);
            const templateFile = path.join(templatesDir, template);

            if (!fs.existsSync(templateFile)) {
                console.error(
                    `❌ Template '${template}' not found in '${templatesDir}'.`,
                );
                return;
            }

            templateContent = fs.readFileSync(templateFile, "utf8");
        }
        templateContent = templateContent.replace(/^#!\/bin\/sh\s*\n?/gm, "");
        mergedContent += `# Template: ${template}\n${templateContent}\n\n`;
    }
    return mergedContent;
};

module.exports = {
    selectTemplate,
    generateTemplateContent,
};
