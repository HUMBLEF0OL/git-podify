const { prompt } = require("enquirer");
const path = require('path');
const fs = require('fs');
const { validateTemplate } = require("./util");
const selectTemplate = async (hookType) => {
    try {
        const choices = [
            { name: 'Linting (npm run lint)', value: 'pre-commit-lint' },
            { name: 'Unit Tests (npm test)', value: 'pre-commit-test' },
            { name: 'Commit Message Check (Conventional Commits)', value: 'commit-msg-conventional' },
            { name: 'Custom (create your own)', value: 'custom' }
        ];

        const { templates } = await prompt([
            {
                type: 'multiselect',
                name: 'templates',
                message: `Select templates for ${hookType} (Space: select, A: all, I: invert, Enter: confirm):`,
                choices: choices,
                validate: (value) => value.length > 0 ? true : '❌ You must select at least one template.',
            }
        ]);

        if (templates.includes('Custom (create your own)') && templates.length > 1) {
            console.warn(`⚠️ You selected both 'Custom' and predefined templates. 'Custom' will be applied, and others will be ignored.`);
            return ['custom'];
        }

        // Find the corresponding values for selected templates
        return templates.map(templateName => {
            const selectedChoice = choices.find(choice => choice.name === templateName);
            return selectedChoice.value;
        });
    } catch (err) {
        console.error(`❌ Template selection failed: ${err.message}`);
        throw err;
    }
};

const generateTemplateContent = async (templates) => {
    let mergedContent = `#!/bin/sh\n\n# Generated by GitPodify\n\n`;
    for (const template of templates) {
        let templateContent = '';
        if (template === 'custom') {
            const { customTemplatePath } = await prompt({
                type: 'input',
                name: 'customTemplatePath',
                message: 'Enter the absolute path to your custom template file:',
                validate: (value) => validateTemplate(value) ? true : 'Invalid path or file format.',
            });
            templateContent = fs.readFileSync(customTemplatePath, 'utf8');
        } else {
            const templatesDir = path.join(process.cwd(), 'lib', 'templates');
            const templateFile = path.join(templatesDir, template);

            if (!fs.existsSync(templateFile)) {
                console.error(`❌ Template '${template}' not found in '${templatesDir}'.`);
                return;
            }

            templateContent = fs.readFileSync(templateFile, 'utf8');
        }
        templateContent = templateContent.replace(/^#!\/bin\/sh\s*\n?/gm, '');
        mergedContent += `# Template: ${template}\n${templateContent}\n\n`;
    }
    return mergedContent;
}


module.exports = {
    selectTemplate,
    generateTemplateContent
}